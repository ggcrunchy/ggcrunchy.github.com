"use strict";(self.webpackChunkggcrunchy_docs=self.webpackChunkggcrunchy_docs||[]).push([[8542],{663:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>c,toc:()=>o});var s=n(4848),a=n(8453);const r={sidebar_position:5},i=void 0,c={id:"plugins/list/generator",title:"generator",description:"Rough docs:",source:"@site/docs/plugins/list/generator.md",sourceDirName:"plugins/list",slug:"/plugins/list/generator",permalink:"/docs/plugins/list/generator",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/plugins/list/generator.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"pluginsSidebar",previous:{title:"clipper",permalink:"/docs/plugins/list/clipper"},next:{title:"impack",permalink:"/docs/plugins/list/impack"}},h={},o=[];function p(e){const t={code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Rough docs:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"FUNCS"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'\tshape = createBezierShape(control) -- table, may be between 2 and 8 vec2 values\n\tshape = createBezierShape(params) -- control must be table in params\n\n\t\tint segments = 16;\n\n\tshape = createCircleShape(opts)\n\t\t\t\n\t\tdouble radius = 1.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint segments = 32;\n\n\tshape = createGridShape(opts)\n\n\t\tgml::dvec2 size = {1.0, 1.0};\n\t\tgml::ivec2 segments = {4, 4}, subSegments = {2, 2};\n\n\tshape = createLineShape()\n\n\t\tgml::dvec2 start = {0.0, -1.0}, end = {0.0, 1.0};\n\t\tint segments = 8;\n\n\tOUTPUT = { "px", "py", "tx", "ty", "u" } (could be properties in vertex writer?)\n\n\tshape = createParametricShape(func) -- func(output, t) TODO keys, etc. (and double-check implementation... stack off?)\n\tshape = createParametricShape(params) -- func must be function in params\n\n\t\tint segments = 16;\n\n\tshape = createRectangleShape(opts)\n\n\t\tgml::dvec2 size = gml::dvec2{1.0, 1.0};\n\t\tgml::ivec2 segments = gml::ivec2{8, 8};\n\n\tshape = createRoundedRectangleShape(opts)\n\n\t\tgml::dvec2 size = {0.75, 0.75};\n\t\tgml::ivec2 segments = {8, 8};\n\t\tdouble radius = 0.25;\n\t\tint slices = 4;\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"METHODS:"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"\tshape = shape:AxisSwap()\n\tshape = shape:Flip()\n\tedge_generator = shape:Edges()\n\tmesh = shape:Extrude(path)\n\t\n\tshape:ForEachEdge(func) -- func(index1, index2), 1-based\n\tshape:ForEachVertex(func) -- func(shape_vertex)\n\n\tmesh = shape:Lathe(opts)\n\t\t\t\t\n\t\tgenerator::Axis axis = generator::Axis::X;\n\t\tdouble start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32;\n\n\tshape = shape:Merge(shape2[, shape3[, shape4]])\n\tshape = shape:Repeat(count, delta) -- vec2\n\tshape = shape:Rotate(angle)\n\tshape = shape:Scale(scaling) -- vec2\n\tshape = shape:Subdivide()\n\tshape = shape:Transform(func) -- func(output) TODO keys, etc.\n\tshape = shape:Translate(delta) -- vec2\n\t\n\tshape_vertex_generator = shape:Vertices()\n\n\tx, y = shape_vertex:GetNormal()\n\tx, y = shape_vertex:GetPosition()\n\tx, y = shape_vertex:GetTangent()\n\tu = shape_vertex:GetTexCoord()\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"FUNCS:"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'\tpath = createHelixPath(opts)\n\n\t\tdouble radius = 1.0, size = 1.0, start = 0.0, sweep = gml::radians(720.0);\n\t\tint segments = 32;\n\n\tpath = createKnotPath(opts)\n\n\t\tint p = 2, q = 3, segments = 96;\n\n\tpath = createLinePath(opts)\n\n\t\tgml::dvec3 start = {0.0, 0.0, -1.0}, end = {0.0, 0.0, 1.0}, normal = {1.0, 0.0, 0.0};\n\t\tint segments = 8;\n\n\tOUTPUT = { "nx", "ny", "nz", "px", "py", "pz", "tx", "ty", "tz", "u" } \n\n\tpath = createParametricPath(func) -- func(output, t)\n\tpath = createParametricPath(params)\n\n\t\tint segments = 16;\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"METHODS:"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"\tpath = path:AxisSwap(xaxis, yaxis, zaxis)\n\tedge_generator = path:Edges()\n\tpath = path:Flip()\n\t\n\tpath:ForEachEdge(func) -- func(index1, index2)\n\tpath:ForEachVertex(func) -- func(path_vertex)\n\n\tpath = path:Merge(path2[, path3[, path4]])\n\tpath = path:Repeat(count, delta) -- vec3\n\tpath = path:Rotate(quat) -- x, y, z, w fields\n\tpath = path:Rotate(angle, axis) -- vec3\n\tpath = path:Scale(scaling) -- vec3\n\tpath = path:Subdivide()\n\tpath = path:Transform(func) -- func(output) TODO keys, etc.\n\tpath = path:Translate(delta) -- vec3\n\n\tpath_vertex_generator = path:Vertices()\n\t\n\tx, y, z = path_vertex:GetBinormal()\n\tx, y, z = path_vertex:GetNormal()\n\tx, y, z = path_vertex:GetPosition()\n\tx, y, z = path_vertex:GetTangent()\n\tu = path_vertex:GetTexCoord()\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"FUNCS:"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'\tmesh = createBezierMesh(control) -- M x N table, M and N may each be from 2 to 5\n\tmesh = createBezierMesh(params) -- control must be table in params\n\n\t\tgml::ivec2 segments = {16, 16};\n\n\tmesh = createBoxMesh(opts)\n\n\t\tgml::dvec3 size = {1.0, 1.0, 1.0};\n\t\tgml::ivec3 segments = {8, 8, 8};\n\n\tmesh = createCappedConeMesh(opts)\n\n\t\tdouble radius = 1.0, size = 1.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, segments = 8, rings = 4;\n\n\tmesh = createCappedCylinderMesh(opts)\n\t\n\t\tdouble radius = 1.0, size = 1.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, segments = 8, rings = 4;\n\n\tmesh = createCappedTubeMesh(opts)\n\n\t\tdouble radius = 1.0, innerRadius = 0.75, size = 1.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, segments = 8, rings = 1;\n\n\tmesh = createCapsuleMesh(opts)\n\t\n\t\tdouble radius = 1.0, size = 0.5, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, segments = 4, rings = 8;\n\n\tmesh = createConeMesh(opts)\n\t\n\t\tdouble radius = 1.0, size = 1.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, segments = 8;\n\n\tmesh = createConvexPolygonMesh(opts)\n\t\n\t\tstd::vector<gml::dvec2> v2; // vec2List\n\t\tstd::vector<gml::dvec3> v3; // vec3List\n\n\t\tdouble radius = 1.0;\n\t\tint sides = 5, segments = 4, rings = 4;\n\t\t\n\tmesh = createCylinderMesh(opts)\n\n\t\tdouble radius = 1.0, size = 1.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, segments = 8;\n\n\tmesh = createDiskMesh(opts)\n\n\t\tdouble radius = 1.0, innerRadius = 0.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, rings = 4;\n\n\tmesh = createDodecahedronMesh(opts)\n\n\t\tdouble radius = 1.0;\n\t\tint segments = 1, rings = 1;\n\n\tmesh = createIcosahedronMesh(opts)\n\n\t\tdouble radius = 1.0;\n\t\tint segments = 1;\n\n\tmesh = createIcoSphereMesh(opts)\n\n\t\tdouble radius = 1.0;\n\t\tint segments = 4;\n\n\tOUTPUT = { "nx", "ny", "nz", "px", "py", "pz", "u", "v" }\n\n\tmesh = createParametricMesh(func) -- func(output, u, v)\n\tmesh = createParametricMesh(params)\n\n\t\tgml::ivec2 segments = {16, 16};\n\n\tmesh = createPlaneMesh(opts)\n\n\t\tgml::dvec2 size = {1.0, 1.0};\n\t\tgml::ivec2 segments = {8, 8};\n\n\tmesh = createRoundedBoxMesh(opts)\n\n\t\tgml::dvec3 size = {0.75, 0.75, 0.75};\n\t\tgml::ivec3 segments = {8, 8, 8};\n\t\tdouble radius = 0.25;\n\t\tint slices = 4;\n\n\tmesh = createSphereMesh(opts)\n\n\t\tdouble radius = 1.0, sliceStart = 0.0, sliceSweep = gml::radians(360.0), segmentStart = 0.0, segmentSweep = gml::radians(180.0);\n\t\tint slices = 32, segments = 16;\n\n\tmesh = createSphericalConeMesh(opts)\n\n\t\tdouble radius = 1.0, size = 1.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, segments = 8, rings = 4;\n\n\tmesh = createSphericalTriangleMesh(opts)\n\t\n\t\tgml::dvec3 v0, v1, v2; // same name\n\t\tdouble radius = 1.0;\n\t\tint segments = 4;\n\n\tmesh = createSpringMesh(opts)\n\n\t\tdouble minor = 0.25, major = 1.0, size = 1.0, minorStart = 0.0, minorSweep = gml::radians(360.0), majorStart = 0.0, majorSweep = gml::radians(720.0);\n\t\tint slices = 8, segments = 32;\n\n\tmesh = createTeapotMesh(opts)\n\n\t\tint segments = 8;\n\n\tmesh = createTorusMesh(opts)\n\n\t\tdouble minor = 0.25, major = 1.0, minorStart = 0.0, minorSweep = gml::radians(360.0), majorStart = 0.0, majorSweep = gml::radians(360.0);\n\t\tint slices = 16, segments = 32;\n\n\tmesh = createTorusKnotMesh(opts)\n\n\t\tint p = 2, q = 3, slices = 8, segments = 96;\n\n\tmesh = createTriangleMesh(opts)\n\n\t\tgml::dvec3 v0, v1, v2; // same name\n\n\t\tdouble radius = 1.0;\n\t\tint segments = 4;\n\n\tmesh = createTubeMesh(opts)\n\n\t\tdouble radius = 1.0, innerRadius = 0.75, size = 1.0, start = 0.0, sweep = gml::radians(360.0);\n\t\tint slices = 32, segments = 8;\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"METHODS:"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"\tmesh = mesh:AxisSwap(xaxis, yaxis, zaxis)\n\tmesh = mesh:Flip()\n\n\tmesh:ForEachTriangle(func) -- func(index1, index2, index3)\n\tmesh:ForEachVertex(func) -- func(mesh_vertex)\n\n\tmesh = path:Merge(mesh2[, mesh3[, mesh4]])\n\tmesh = mesh:Repeat(count, delta) -- vec3\n\tmesh = mesh:Rotate(q) -- x, y, z, w fields\n\tmesh = mesh:Rotate(angle, axis) -- vec3\n\tmesh = mesh:Scale(scaling) -- vec3\n\tmesh = mesh:Spherify(radius, factor)\n\tmesh = mesh:Subdivide(n) -- n = 1 to 4\n\tmesh = mesh:Transform(func) -- func(output) TODO keys, etc.\n\tmesh = mesh:Translate(delta) -- vec3\n\n\ttriangle_generator = mesh:Triangles()\n\n\tmesh = mesh:UvFlip(u, v) -- booleans\n\tmesh = mesh:UvSwap()\n\n\tmesh_vertex_generator = mesh:Vertices()\n\n\tx, y, z = mesh_vertex:GetNormal()\n\tx, y, z = mesh_vertex:GetPosition()\n\tu, v = mesh_vertex:GetTexCoord()\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"METHODS"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"\tis_done = generator:Done()\n\tgenerator:Next() -- error if already done\n\n\tindex1, index2 = edge_generator:Generate() -- ditto on error\n\tindex1, index2, index3 = triangle_generator:Generate() -- ditto on error\n\tshape_vertex = shape_vertex_generator:Generate() -- ditto; vertex will be invalidated by next Generate()\n\tpath_vertex = path_vertex_generator:Generate() -- ditto\n\tmesh_vertex = mesh_vertex_generator:Generate() -- ditto\n"})})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var s=n(6540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);